# 02. 객체들에게 연락 돌리기: 옵저버 패턴

- **옵저버 패턴**(Observer Pattern)은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의한다.
- 보통 주제 인터페이스와 옵저버 인터페이스가 들어있는 클래스 디자인으로 구현

- 출판-구독(Publish-Subscribe) 패턴은 구독자가 서로 다른 유형의 메시지에 관심을 가질 수 있고, 출판사와 구독자를 더 세세하게 분리할 수 있다. 미들웨어 시스템에서 종종 사용

- **느슨한 결합**(Loose Coupling): 객체들이 상호작용할 수는 있지만, 서로를 잘 모르는 관계
  - 옵저버에서 느슨한 결합을 만드는 방법
    1. 주제는 옵저버가 특정 인터페이스(Observer 인터페이스)를 구현한다는 사실만 안다.
    2. 옵저버는 언제든지 새로 추가할 ㅅ 있다.
    3. 새로운 형식의 옵저버를 추가할 때도 주제를 변경할 필요가 없다.
    4. 주제와 옵저버는 서로 독립적으로 재사용할 수 있다.
    5. 주제나 옵저버가 달라져도 서로에게 영향을 미치지는 않는다.

#### 디자인 원칙: 상호 작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다.

- 옵저버가 필요할 때마다 주제로부터 데이터를 당겨오는 방식(pull)이 대체로 확장이 더 쉽다.



#### 객체지향 기초

- 추상화
- 캡슐화
- 다형성
- 상속



#### 객체지향 원칙

- 바뀌는 부분은 캡슐화한다.
- 상속보다는 구성을 활용한다.
- 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
- 상호작용하는 객체 사이에서는 가능하면 느슨한 결합을 사용해야 한다.
  - 느슨한 결합을 이용하는 디자인이 훨씬 더 유연하고 변화에 강하다.



#### 객체지향 패턴

- 옵저버 패턴: 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의한다.



#### 핵심 정리

- 옵저버 패턴은 객체들 사이에 일대다 관계를 정의한다.
- 주제는 동일한 인터페이스를 써서 옵저버에게 연락한다.
- Observer 인터페이스를 구현하기만 하면 어떤 구상 클래스의 옵저버라도 패턴에 참여할 수 있다.
- 주제는 옵저버들이 Observer 인터페이스를 구현한다는 것을 제외하면 옵저버에 관해 전혀 모른다. 따라서 이들 사이의 결합은 느슨한 결합이다.
- 옵저버 패턴을 사용하면 주제가 데이터를 보내거나(푸시) 옵저버가 데이터를 가져올(풀) 수 있다.
  - 일반적으로 풀 방식이 더 '옳은' 방식이라고 간주
- 스윙은 다른 여러 GUI 프레임워크와 마찬가지로 옵저버 패턴을 많이 사용한다.
- 옵저버 패턴은 여러 개의 주제와 메시지 유형이 있는 복잡한 상황에서 사용하는 출판-구독패턴과 친척이다.
- 옵저버 패턴은 자주 쓰이는 패턴으로 모델-뷰-컨트롤러(MVC)를 배울 때 다시 만날 수 있다.



#### 디자인 원칙

- 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
  - 옵저버 패턴에서 변하는 것은 주제의 상태와 옵저버의 개수, 형식
  - 옵저버 패턴에서는 주제를 바꾸지 않고도 주제의 상태에 의존하는 객체들을 바꿀 수 있다. 나중에 바뀔 것을 대비해 두면 편하게 작업할 수 있다.
- 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
  - 주제와 옵저버에서 모두 인터페이스를 사용했다. 주제는 subject 인터페이스로 observer 인터페이스를 구현하는 객체들의 등록과 탈퇴를 관리하고, 그런 객체들에게 연락을 돌린다. 이러면 느슨한 결합을 만들 수 있다.
- 상속보다는 구성을 활용한다.
  - 옵저버 패턴에서는 구성을 활용해서 옵저버들을 관리한다. 주제와 옵저버 사이의 관계는 상속이 아니라 구성으로 이루어지기 때문이다.